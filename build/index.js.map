{"version":3,"sources":["webpack://SimpleKeyboard/webpack/universalModuleDefinition","webpack://SimpleKeyboard/webpack/bootstrap","webpack://SimpleKeyboard/webpack/runtime/define property getters","webpack://SimpleKeyboard/webpack/runtime/hasOwnProperty shorthand","webpack://SimpleKeyboard/webpack/runtime/make namespace object","webpack://SimpleKeyboard/./src/lib/services/Utilities.ts","webpack://SimpleKeyboard/./src/lib/services/PhysicalKeyboard.ts","webpack://SimpleKeyboard/./src/lib/components/Keyboard.ts","webpack://SimpleKeyboard/./src/lib/index.ts","webpack://SimpleKeyboard/./src/lib/services/KeyboardLayout.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Utilities","getOptions","getCaretPosition","getCaretPositionEnd","dispatch","this","bindMethods","myClass","instance","getOwnPropertyNames","myMethod","bind","button","buttonTypeClass","includes","buttonWithoutBraces","replace","buttonNormalized","display","mergeDisplay","assign","getDefaultDiplay","input","caretPos","caretPosEnd","moveCaret","options","commonParams","output","length","removeAt","addStringAt","tabCharOnTab","newLineOnEnter","Number","isInteger","minus","newCaretPos","updateCaretPosAction","setCaretPosition","caretPosition","debug","console","log","source","str","position","positionEnd","slice","join","isMaxLengthReached","updateCaretPos","emojiMatchedReg","substring","match","substr","inputObj","updatedInput","maxLength","currentInput","inputName","condition","maxLengthReached","Boolean","window","navigator","maxTouchPoints","PointerEvent","toLowerCase","trim","split","reduce","word","toUpperCase","PhysicalKeyboard","event","buttonPressed","getSimpleKeyboardLayoutKey","buttonDOM","getButtonElement","style","backgroundColor","physicalKeyboardHighlightBgColor","color","physicalKeyboardHighlightTextColor","physicalKeyboardHighlightPress","onpointerdown","onmousedown","ontouchstart","removeAttribute","onpointerup","onmouseup","ontouchend","code","params","keyboardDOMClass","keyboardDOM","document","querySelector","HTMLDivElement","className","warn","Error","caretPositionEnd","name","initCallback","modules","baseDOMClasses","keyboardClasses","filter","DOMClass","handleParams","utilities","layoutName","theme","preventMouseDownDefault","keyboardPluginClasses","SimpleKeyboard","buttonElements","currentInstanceName","camelCase","allKeyboardInstances","keyboardInstanceNames","keys","isFirstKeyboardInstance","physicalKeyboard","render","loadModules","endPosition","onKeyPress","getUpdatedInput","inputPattern","inputPatternIsValid","handleMaxLength","getAllInputs","syncInstanceInputs","onChange","getInput","onChangeAll","e","preventDefault","stopMouseDownPropagation","stopPropagation","target","classList","add","activeButtonClass","holdInteractionTimeout","clearTimeout","holdTimeout","isMouseHold","disableButtonHold","setTimeout","handleButtonHold","preventMouseUpDefault","stopMouseUpPropagation","recurseButtons","buttonElement","remove","onKeyReleased","handleButtonClicked","replaceInput","skipSync","rtl","inputWithoutRTLControl","forEach","changedOptions","onSetOptions","newOptions","optionName","JSON","stringify","innerHTML","callback","buttons","classNameItem","buttonTheme","classNameFound","map","buttonThemeArray","push","class","Array","isArray","index","filteredButtonArray","item","splice","buttonArr","inputVal","inputPatternRaw","RegExp","didInputMatch","test","addEventListener","handleKeyUp","handleKeyDown","handleMouseUp","handleTouchEnd","caretEventHandler","physicalKeyboardHighlight","handleHighlightKeyUp","handleHighlightKeyDown","targetTagName","tagName","isKeyboard","contains","disableCaretPositioning","selectionStart","selectionEnd","fn","buttonName","removeEventListener","ontouchcancel","deleteButton","onpointercancel","onclick","clear","initialized","buttonClasses","themeObj","themeObjClasses","buttonAttributes","attrObj","attribute","processAutoTouchEvents","disableContextualWindow","oncontextmenu","autoUseTouchEvents","useTouchEvents","setEventListeners","onInit","isTouchDevice","onTouchDeviceDetected","beforeFirstRender","pointerEventsSupported","useMouseEvents","beforeRender","onRender","onModulesLoaded","KeyboardModule","init","rowDOM","rowIndex","containerStartIndexes","containerEndIndexes","rowDOMArray","from","children","removedElements","startIndex","arrIndex","endIndex","updated_startIndex","updated_endIndex","containerDOM","createElement","containerUID","setAttribute","containedElements","element","appendChild","layoutClass","layout","default","shift","useTouchEventsClass","disableRowButtonContainers","getKeyboardClassString","row","rIndex","rowArray","bIndex","buttonHasContainerStart","indexOf","buttonHasContainerEnd","fctBtnClass","getButtonClass","buttonDisplayName","getButtonDisplayName","buttonType","useButtonTag","getButtonThemeClasses","setDOMButtonAttributes","handleButtonMouseDown","handleButtonMouseUp","buttonUID","buttonSpanDOM","parseRowDOMContainers","handleKeyboardContainerMouseDown"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SimpleKeyboard\"] = factory();\n\telse\n\t\troot[\"SimpleKeyboard\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { KeyboardInput } from \"./../interfaces\";\nimport { KeyboardOptions, UtilitiesParams } from \"../interfaces\";\n\n/**\n * Utility Service\n */\nclass Utilities {\n  getOptions: () => KeyboardOptions;\n  getCaretPosition: () => number;\n  getCaretPositionEnd: () => number;\n  dispatch: any;\n  maxLengthReached: boolean;\n\n  /**\n   * Creates an instance of the Utility service\n   */\n  constructor({\n    getOptions,\n    getCaretPosition,\n    getCaretPositionEnd,\n    dispatch,\n  }: UtilitiesParams) {\n    this.getOptions = getOptions;\n    this.getCaretPosition = getCaretPosition;\n    this.getCaretPositionEnd = getCaretPositionEnd;\n    this.dispatch = dispatch;\n\n    /**\n     * Bindings\n     */\n    Utilities.bindMethods(Utilities, this);\n  }\n\n  /**\n   * Adds default classes to a given button\n   *\n   * @param  {string} button The button's layout name\n   * @return {string} The classes to be added to the button\n   */\n  getButtonClass(button: string) {\n    const buttonTypeClass =\n      button.includes(\"{\") && button.includes(\"}\") && button !== \"{//}\"\n        ? \"functionBtn\"\n        : \"standardBtn\";\n    const buttonWithoutBraces = button.replace(\"{\", \"\").replace(\"}\", \"\");\n    let buttonNormalized = \"\";\n\n    if (buttonTypeClass !== \"standardBtn\")\n      buttonNormalized = ` hg-button-${buttonWithoutBraces}`;\n\n    return `hg-${buttonTypeClass}${buttonNormalized}`;\n  }\n\n  /**\n   * Default button display labels\n   */\n  getDefaultDiplay() {\n    return {\n      \"{bksp}\": \"backspace\",\n      \"{backspace}\": \"backspace\",\n      \"{enter}\": \"< enter\",\n      \"{shift}\": \"shift\",\n      \"{shiftleft}\": \"shift\",\n      \"{shiftright}\": \"shift\",\n      \"{alt}\": \"alt\",\n      \"{s}\": \"shift\",\n      \"{tab}\": \"tab\",\n      \"{lock}\": \"caps\",\n      \"{capslock}\": \"caps\",\n      \"{accept}\": \"Submit\",\n      \"{space}\": \" \",\n      \"{//}\": \" \",\n      \"{esc}\": \"esc\",\n      \"{escape}\": \"esc\",\n      \"{f1}\": \"f1\",\n      \"{f2}\": \"f2\",\n      \"{f3}\": \"f3\",\n      \"{f4}\": \"f4\",\n      \"{f5}\": \"f5\",\n      \"{f6}\": \"f6\",\n      \"{f7}\": \"f7\",\n      \"{f8}\": \"f8\",\n      \"{f9}\": \"f9\",\n      \"{f10}\": \"f10\",\n      \"{f11}\": \"f11\",\n      \"{f12}\": \"f12\",\n      \"{numpaddivide}\": \"/\",\n      \"{numlock}\": \"lock\",\n      \"{arrowup}\": \"↑\",\n      \"{arrowleft}\": \"←\",\n      \"{arrowdown}\": \"↓\",\n      \"{arrowright}\": \"→\",\n      \"{prtscr}\": \"print\",\n      \"{scrolllock}\": \"scroll\",\n      \"{pause}\": \"pause\",\n      \"{insert}\": \"ins\",\n      \"{home}\": \"home\",\n      \"{pageup}\": \"up\",\n      \"{delete}\": \"del\",\n      \"{end}\": \"end\",\n      \"{pagedown}\": \"down\",\n      \"{numpadmultiply}\": \"*\",\n      \"{numpadsubtract}\": \"-\",\n      \"{numpadadd}\": \"+\",\n      \"{numpadenter}\": \"enter\",\n      \"{period}\": \".\",\n      \"{numpaddecimal}\": \".\",\n      \"{numpad0}\": \"0\",\n      \"{numpad1}\": \"1\",\n      \"{numpad2}\": \"2\",\n      \"{numpad3}\": \"3\",\n      \"{numpad4}\": \"4\",\n      \"{numpad5}\": \"5\",\n      \"{numpad6}\": \"6\",\n      \"{numpad7}\": \"7\",\n      \"{numpad8}\": \"8\",\n      \"{numpad9}\": \"9\",\n    };\n  }\n  /**\n   * Returns the display (label) name for a given button\n   *\n   * @param  {string} button The button's layout name\n   * @param  {object} display The provided display option\n   * @param  {boolean} mergeDisplay Whether the provided param value should be merged with the default one.\n   */\n  getButtonDisplayName(\n    button: string,\n    display: KeyboardOptions[\"display\"],\n    mergeDisplay: boolean\n  ) {\n    if (mergeDisplay) {\n      display = Object.assign({}, this.getDefaultDiplay(), display);\n    } else {\n      display = display || this.getDefaultDiplay();\n    }\n\n    return display[button] || button;\n  }\n\n  /**\n   * Returns the updated input resulting from clicking a given button\n   *\n   * @param  {string} button The button's layout name\n   * @param  {string} input The input string\n   * @param  {number} caretPos The cursor's current position\n   * @param  {number} caretPosEnd The cursor's current end position\n   * @param  {boolean} moveCaret Whether to update simple-keyboard's cursor\n   */\n  getUpdatedInput(\n    button: string,\n    input: string,\n    caretPos: number,\n    caretPosEnd = caretPos,\n    moveCaret = false\n  ) {\n    const options = this.getOptions();\n    const commonParams: [number, number, boolean] = [\n      caretPos,\n      caretPosEnd,\n      moveCaret,\n    ];\n\n    let output = input;\n\n    if (\n      (button === \"{bksp}\" || button === \"{backspace}\") &&\n      output.length > 0\n    ) {\n      output = this.removeAt(output, ...commonParams);\n    } else if (button === \"{space}\")\n      output = this.addStringAt(output, \" \", ...commonParams);\n    else if (\n      button === \"{tab}\" &&\n      !(\n        typeof options.tabCharOnTab === \"boolean\" &&\n        options.tabCharOnTab === false\n      )\n    ) {\n      output = this.addStringAt(output, \"\\t\", ...commonParams);\n    } else if (\n      (button === \"{enter}\" || button === \"{numpadenter}\") &&\n      options.newLineOnEnter\n    )\n      output = this.addStringAt(output, \"\\n\", ...commonParams);\n    else if (\n      button.includes(\"numpad\") &&\n      Number.isInteger(Number(button[button.length - 2]))\n    ) {\n      output = this.addStringAt(\n        output,\n        button[button.length - 2],\n        ...commonParams\n      );\n    } else if (button === \"{numpaddivide}\")\n      output = this.addStringAt(output, \"/\", ...commonParams);\n    else if (button === \"{numpadmultiply}\")\n      output = this.addStringAt(output, \"*\", ...commonParams);\n    else if (button === \"{numpadsubtract}\")\n      output = this.addStringAt(output, \"-\", ...commonParams);\n    else if (button === \"{numpadadd}\")\n      output = this.addStringAt(output, \"+\", ...commonParams);\n    else if (button === \"{numpaddecimal}\")\n      output = this.addStringAt(output, \".\", ...commonParams);\n    else if (button === \"{\" || button === \"}\")\n      output = this.addStringAt(output, button, ...commonParams);\n    else if (!button.includes(\"{\") && !button.includes(\"}\"))\n      output = this.addStringAt(output, button, ...commonParams);\n\n    return output;\n  }\n\n  /**\n   * Moves the cursor position by a given amount\n   *\n   * @param  {number} length Represents by how many characters the input should be moved\n   * @param  {boolean} minus Whether the cursor should be moved to the left or not.\n   */\n  updateCaretPos(length: number, minus = false) {\n    const newCaretPos = this.updateCaretPosAction(length, minus);\n\n    this.dispatch((instance: any) => {\n      instance.setCaretPosition(newCaretPos);\n    });\n  }\n\n  /**\n   * Action method of updateCaretPos\n   *\n   * @param  {number} length Represents by how many characters the input should be moved\n   * @param  {boolean} minus Whether the cursor should be moved to the left or not.\n   */\n  updateCaretPosAction(length: number, minus = false) {\n    const options = this.getOptions();\n    let caretPosition = this.getCaretPosition();\n\n    if (minus) {\n      if (caretPosition > 0) caretPosition = caretPosition - length;\n    } else {\n      caretPosition = caretPosition + length;\n    }\n\n    if (options.debug) {\n      console.log(\"Caret at:\", caretPosition);\n    }\n\n    return caretPosition;\n  }\n\n  /**\n   * Adds a string to the input at a given position\n   *\n   * @param  {string} source The source input\n   * @param  {string} str The string to add\n   * @param  {number} position The (cursor) position where the string should be added\n   * @param  {boolean} moveCaret Whether to update simple-keyboard's cursor\n   */\n  addStringAt(\n    source: string,\n    str: string,\n    position = source.length,\n    positionEnd = source.length,\n    moveCaret = false\n  ) {\n    let output;\n\n    if (!position && position !== 0) {\n      output = source + str;\n    } else {\n      output = [source.slice(0, position), str, source.slice(positionEnd)].join(\n        \"\"\n      );\n\n      /**\n       * Avoid caret position change when maxLength is set\n       */\n      if (!this.isMaxLengthReached()) {\n        if (moveCaret) this.updateCaretPos(str.length);\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * Removes an amount of characters at a given position\n   *\n   * @param  {string} source The source input\n   * @param  {number} position The (cursor) position from where the characters should be removed\n   * @param  {boolean} moveCaret Whether to update simple-keyboard's cursor\n   */\n  removeAt(\n    source: string,\n    position = source.length,\n    positionEnd = source.length,\n    moveCaret = false\n  ) {\n    if (position === 0 && positionEnd === 0) {\n      return source;\n    }\n\n    let output;\n\n    if (position === positionEnd) {\n      let prevTwoChars;\n      let emojiMatched;\n      const emojiMatchedReg = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])/g;\n\n      /**\n       * Emojis are made out of two characters, so we must take a custom approach to trim them.\n       * For more info: https://mathiasbynens.be/notes/javascript-unicode\n       */\n      if (position && position >= 0) {\n        prevTwoChars = source.substring(position - 2, position);\n        emojiMatched = prevTwoChars.match(emojiMatchedReg);\n\n        if (emojiMatched) {\n          output = source.substr(0, position - 2) + source.substr(position);\n          if (moveCaret) this.updateCaretPos(2, true);\n        } else {\n          output = source.substr(0, position - 1) + source.substr(position);\n          if (moveCaret) this.updateCaretPos(1, true);\n        }\n      } else {\n        prevTwoChars = source.slice(-2);\n        emojiMatched = prevTwoChars.match(emojiMatchedReg);\n\n        if (emojiMatched) {\n          output = source.slice(0, -2);\n          if (moveCaret) this.updateCaretPos(2, true);\n        } else {\n          output = source.slice(0, -1);\n          if (moveCaret) this.updateCaretPos(1, true);\n        }\n      }\n    } else {\n      output = source.slice(0, position) + source.slice(positionEnd);\n      if (moveCaret) {\n        this.dispatch((instance: any) => {\n          instance.setCaretPosition(position);\n        });\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Determines whether the maxLength has been reached. This function is called when the maxLength option it set.\n   *\n   * @param  {object} inputObj\n   * @param  {string} updatedInput\n   */\n  handleMaxLength(inputObj: KeyboardInput, updatedInput: string) {\n    const options = this.getOptions();\n    const maxLength = options.maxLength;\n    const currentInput = inputObj[options.inputName];\n    const condition = updatedInput.length - 1 >= maxLength;\n\n    if (\n      /**\n       * If pressing this button won't add more characters\n       * We exit out of this limiter function\n       */\n      updatedInput.length <= currentInput.length\n    ) {\n      return false;\n    }\n\n    if (Number.isInteger(maxLength)) {\n      if (options.debug) {\n        console.log(\"maxLength (num) reached:\", condition);\n      }\n\n      if (condition) {\n        /**\n         * @type {boolean} Boolean value that shows whether maxLength has been reached\n         */\n        this.maxLengthReached = true;\n        return true;\n      } else {\n        this.maxLengthReached = false;\n        return false;\n      }\n    }\n\n    if (typeof maxLength === \"object\") {\n      const condition = updatedInput.length - 1 >= maxLength[options.inputName];\n\n      if (options.debug) {\n        console.log(\"maxLength (obj) reached:\", condition);\n      }\n\n      if (condition) {\n        this.maxLengthReached = true;\n        return true;\n      } else {\n        this.maxLengthReached = false;\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Gets the current value of maxLengthReached\n   */\n  isMaxLengthReached() {\n    return Boolean(this.maxLengthReached);\n  }\n\n  /**\n   * Determines whether a touch device is being used\n   */\n  isTouchDevice() {\n    return \"ontouchstart\" in window || navigator.maxTouchPoints;\n  }\n\n  /**\n   * Determines whether pointer events are supported\n   */\n  pointerEventsSupported() {\n    return window.PointerEvent;\n  }\n\n  /**\n   * Bind all methods in a given class\n   */\n\n  static bindMethods(myClass: any, instance: any) {\n    // eslint-disable-next-line no-unused-vars\n    for (const myMethod of Object.getOwnPropertyNames(myClass.prototype)) {\n      const excludeMethod =\n        myMethod === \"constructor\" || myMethod === \"bindMethods\";\n      if (!excludeMethod) {\n        instance[myMethod] = instance[myMethod].bind(instance);\n      }\n    }\n  }\n\n  /**\n   * Transforms an arbitrary string to camelCase\n   *\n   * @param  {string} str The string to transform.\n   */\n  camelCase(str: string): string {\n    if (!str) return;\n\n    return str\n      .toLowerCase()\n      .trim()\n      .split(/[.\\-_\\s]/g)\n      .reduce((str, word) =>\n        word.length ? str + word[0].toUpperCase() + word.slice(1) : str\n      );\n  }\n\n  static noop = () => {};\n}\n\nexport default Utilities;\n","import { KeyboardOptions, UtilitiesParams } from \"../interfaces\";\nimport Utilities from \"../services/Utilities\";\n\n/**\n * Physical Keyboard Service\n */\nclass PhysicalKeyboard {\n  getOptions: () => KeyboardOptions;\n  dispatch: any;\n\n  /**\n   * Creates an instance of the PhysicalKeyboard service\n   */\n  constructor({ dispatch, getOptions }: Partial<UtilitiesParams>) {\n    /**\n     * @type {object} A simple-keyboard instance\n     */\n    this.dispatch = dispatch;\n    this.getOptions = getOptions;\n\n    /**\n     * Bindings\n     */\n    Utilities.bindMethods(PhysicalKeyboard, this);\n  }\n\n  handleHighlightKeyDown(event: KeyboardEvent) {\n    const options = this.getOptions();\n    const buttonPressed = this.getSimpleKeyboardLayoutKey(event);\n\n    this.dispatch((instance: any) => {\n      const buttonDOM =\n        instance.getButtonElement(buttonPressed) ||\n        instance.getButtonElement(`{${buttonPressed}}`);\n\n      if (buttonDOM) {\n        buttonDOM.style.backgroundColor =\n          options.physicalKeyboardHighlightBgColor || \"#dadce4\";\n        buttonDOM.style.color =\n          options.physicalKeyboardHighlightTextColor || \"black\";\n\n        if (options.physicalKeyboardHighlightPress) {\n          /**\n           * Trigger pointerdown\n           */\n          (\n            buttonDOM.onpointerdown ||\n            buttonDOM.onmousedown ||\n            buttonDOM.ontouchstart ||\n            Utilities.noop\n          )();\n        }\n      }\n    });\n  }\n\n  handleHighlightKeyUp(event: KeyboardEvent) {\n    const options = this.getOptions();\n    const buttonPressed = this.getSimpleKeyboardLayoutKey(event);\n\n    this.dispatch((instance: any) => {\n      const buttonDOM =\n        instance.getButtonElement(buttonPressed) ||\n        instance.getButtonElement(`{${buttonPressed}}`);\n\n      if (buttonDOM && buttonDOM.removeAttribute) {\n        buttonDOM.removeAttribute(\"style\");\n\n        if (options.physicalKeyboardHighlightPress) {\n          /**\n           * Trigger pointerup\n           */\n          (\n            buttonDOM.onpointerup ||\n            buttonDOM.onmouseup ||\n            buttonDOM.ontouchend ||\n            Utilities.noop\n          )();\n        }\n      }\n    });\n  }\n\n  /**\n   * Transforms a KeyboardEvent's \"key.code\" string into a simple-keyboard layout format\n   * @param  {object} event The KeyboardEvent\n   */\n  getSimpleKeyboardLayoutKey(event: KeyboardEvent) {\n    let output;\n\n    if (\n      event.code.includes(\"Numpad\") ||\n      event.code.includes(\"Shift\") ||\n      event.code.includes(\"Space\") ||\n      event.code.includes(\"Backspace\") ||\n      event.code.includes(\"Control\") ||\n      event.code.includes(\"Alt\") ||\n      event.code.includes(\"Meta\")\n    ) {\n      output = event.code;\n    } else {\n      output = event.key;\n    }\n\n    /**\n     * Casting key to lowercase\n     */\n    if (\n      (output && output !== output.toUpperCase()) ||\n      (event.code[0] === \"F\" &&\n        Number.isInteger(Number(event.code[1])) &&\n        event.code.length <= 3)\n    ) {\n      output = output ? output.toLowerCase() : output;\n    }\n\n    return output;\n  }\n}\n\nexport default PhysicalKeyboard;\n","import \"./Keyboard.css\";\n\n// Services\nimport { getDefaultLayout } from \"../services/KeyboardLayout\";\nimport PhysicalKeyboard from \"../services/PhysicalKeyboard\";\nimport Utilities from \"../services/Utilities\";\nimport {\n  KeyboardOptions,\n  KeyboardInput,\n  KeyboardButtonElements,\n  KeyboardHandlerEvent,\n  KeyboardButton,\n} from \"../interfaces\";\n\n/**\n * Root class for simple-keyboard\n * This class:\n * - Parses the options\n * - Renders the rows and buttons\n * - Handles button functionality\n */\nclass SimpleKeyboard {\n  input: KeyboardInput;\n  options: KeyboardOptions;\n  utilities: any;\n  caretPosition: number;\n  caretPositionEnd: number;\n  keyboardDOM: KeyboardButton;\n  keyboardPluginClasses: string;\n  keyboardDOMClass: string;\n  buttonElements: KeyboardButtonElements;\n  currentInstanceName: string;\n  allKeyboardInstances: { [key: string]: SimpleKeyboard };\n  keyboardInstanceNames: string[];\n  isFirstKeyboardInstance: boolean;\n  physicalKeyboard: PhysicalKeyboard;\n  modules: { [key: string]: any };\n  activeButtonClass: string;\n  holdInteractionTimeout: number;\n  holdTimeout: number;\n  isMouseHold: boolean;\n  initialized: boolean;\n\n  /**\n   * Creates an instance of SimpleKeyboard\n   * @param {Array} params If first parameter is a string, it is considered the container class. The second parameter is then considered the options object. If first parameter is an object, it is considered the options object.\n   */\n  constructor(...params: []) {\n    const { keyboardDOMClass, keyboardDOM, options = {} } = this.handleParams(\n      params\n    );\n\n    /**\n     * Initializing Utilities\n     */\n    this.utilities = new Utilities({\n      getOptions: this.getOptions,\n      getCaretPosition: this.getCaretPosition,\n      getCaretPositionEnd: this.getCaretPositionEnd,\n      dispatch: this.dispatch,\n    });\n\n    /**\n     * Caret position\n     */\n    this.caretPosition = null;\n\n    /**\n     * Caret position end\n     */\n    this.caretPositionEnd = null;\n\n    /**\n     * Processing options\n     */\n    this.keyboardDOM = keyboardDOM;\n\n    /**\n     * @type {object}\n     * @property {object} layout Modify the keyboard layout.\n     * @property {string} layoutName Specifies which layout should be used.\n     * @property {object} display Replaces variable buttons (such as {bksp}) with a human-friendly name (e.g.: “backspace”).\n     * @property {boolean} mergeDisplay By default, when you set the display property, you replace the default one. This setting merges them instead.\n     * @property {string} theme A prop to add your own css classes to the keyboard wrapper. You can add multiple classes separated by a space.\n     * @property {array} buttonTheme A prop to add your own css classes to one or several buttons.\n     * @property {array} buttonAttributes A prop to add your own attributes to one or several buttons.\n     * @property {boolean} debug Runs a console.log every time a key is pressed. Displays the buttons pressed and the current input.\n     * @property {boolean} newLineOnEnter Specifies whether clicking the “ENTER” button will input a newline (\\n) or not.\n     * @property {boolean} tabCharOnTab Specifies whether clicking the “TAB” button will input a tab character (\\t) or not.\n     * @property {string} inputName Allows you to use a single simple-keyboard instance for several inputs.\n     * @property {number} maxLength Restrains all of simple-keyboard inputs to a certain length. This should be used in addition to the input element’s maxlengthattribute.\n     * @property {object} maxLength Restrains simple-keyboard’s individual inputs to a certain length. This should be used in addition to the input element’s maxlengthattribute.\n     * @property {boolean} syncInstanceInputs When set to true, this option synchronizes the internal input of every simple-keyboard instance.\n     * @property {boolean} physicalKeyboardHighlight Enable highlighting of keys pressed on physical keyboard.\n     * @property {boolean} physicalKeyboardHighlightPress Presses keys highlighted by physicalKeyboardHighlight\n     * @property {string} physicalKeyboardHighlightTextColor Define the text color that the physical keyboard highlighted key should have.\n     * @property {string} physicalKeyboardHighlightBgColor Define the background color that the physical keyboard highlighted key should have.\n     * @property {boolean} preventMouseDownDefault Calling preventDefault for the mousedown events keeps the focus on the input.\n     * @property {boolean} preventMouseUpDefault Calling preventDefault for the mouseup events.\n     * @property {boolean} stopMouseDownPropagation Stops pointer down events on simple-keyboard buttons from bubbling to parent elements.\n     * @property {boolean} stopMouseUpPropagation Stops pointer up events on simple-keyboard buttons from bubbling to parent elements.\n     * @property {function(button: string):string} onKeyPress Executes the callback function on key press. Returns button layout name (i.e.: “{shift}”).\n     * @property {function(input: string):string} onChange Executes the callback function on input change. Returns the current input’s string.\n     * @property {function} onRender Executes the callback function every time simple-keyboard is rendered (e.g: when you change layouts).\n     * @property {function} onInit Executes the callback function once simple-keyboard is rendered for the first time (on initialization).\n     * @property {function(inputs: object):object} onChangeAll Executes the callback function on input change. Returns the input object with all defined inputs.\n     * @property {boolean} useButtonTag Render buttons as a button element instead of a div element.\n     * @property {boolean} disableCaretPositioning A prop to ensure characters are always be added/removed at the end of the string.\n     * @property {object} inputPattern Restrains input(s) change to the defined regular expression pattern.\n     * @property {boolean} useTouchEvents Instructs simple-keyboard to use touch events instead of click events.\n     * @property {boolean} autoUseTouchEvents Enable useTouchEvents automatically when touch device is detected.\n     * @property {boolean} useMouseEvents Opt out of PointerEvents handling, falling back to the prior mouse event logic.\n     * @property {function} destroy Clears keyboard listeners and DOM elements.\n     * @property {boolean} disableButtonHold Disable button hold action.\n     * @property {boolean} rtl Adds unicode right-to-left control characters to input return values.\n     * @property {function} onKeyReleased Executes the callback function on key release.\n     * @property {array} modules Module classes to be loaded by simple-keyboard.\n     */\n    this.options = options;\n    this.options.layoutName = this.options.layoutName || \"default\";\n    this.options.theme = this.options.theme || \"hg-theme-default\";\n    this.options.inputName = this.options.inputName || \"default\";\n    this.options.preventMouseDownDefault =\n      this.options.preventMouseDownDefault || false;\n\n    /**\n     * @type {object} Classes identifying loaded plugins\n     */\n    this.keyboardPluginClasses = \"\";\n\n    /**\n     * Bindings\n     */\n    Utilities.bindMethods(SimpleKeyboard, this);\n\n    /**\n     * simple-keyboard uses a non-persistent internal input to keep track of the entered string (the variable `keyboard.input`).\n     * This removes any dependency to input DOM elements. You can type and directly display the value in a div element, for example.\n     * @example\n     * // To get entered input\n     * const input = keyboard.getInput();\n     *\n     * // To clear entered input.\n     * keyboard.clearInput();\n     *\n     * @type {object}\n     * @property {object} default Default SimpleKeyboard internal input.\n     * @property {object} myInputName Example input that can be set through `options.inputName:\"myInputName\"`.\n     */\n    this.input = {};\n    this.input[this.options.inputName] = \"\";\n\n    /**\n     * @type {string} DOM class of the keyboard wrapper, normally \"simple-keyboard\" by default.\n     */\n    this.keyboardDOMClass = keyboardDOMClass;\n\n    /**\n     * @type {object} Contains the DOM elements of every rendered button, the key being the button's layout name (e.g.: \"{enter}\").\n     */\n    this.buttonElements = {};\n\n    /**\n     * Simple-keyboard Instances\n     * This enables multiple simple-keyboard support with easier management\n     */\n    if (!window[\"SimpleKeyboardInstances\"])\n      window[\"SimpleKeyboardInstances\"] = {};\n\n    this.currentInstanceName = this.utilities.camelCase(this.keyboardDOMClass);\n    window[\"SimpleKeyboardInstances\"][this.currentInstanceName] = this;\n\n    /**\n     * Instance vars\n     */\n    this.allKeyboardInstances = window[\"SimpleKeyboardInstances\"];\n    this.keyboardInstanceNames = Object.keys(window[\"SimpleKeyboardInstances\"]);\n    this.isFirstKeyboardInstance =\n      this.keyboardInstanceNames[0] === this.currentInstanceName;\n\n    /**\n     * Physical Keyboard support\n     */\n    this.physicalKeyboard = new PhysicalKeyboard({\n      dispatch: this.dispatch,\n      getOptions: this.getOptions,\n    });\n\n    /**\n     * Rendering keyboard\n     */\n    if (this.keyboardDOM) this.render();\n    else {\n      console.warn(`\".${keyboardDOMClass}\" was not found in the DOM.`);\n      throw new Error(\"KEYBOARD_DOM_ERROR\");\n    }\n\n    /**\n     * Modules\n     */\n    this.modules = {};\n    this.loadModules();\n  }\n\n  /**\n   * parseParams\n   */\n  handleParams = (\n    params: any[]\n  ): {\n    keyboardDOMClass: string;\n    keyboardDOM: KeyboardButton;\n    options: Partial<KeyboardOptions>;\n  } => {\n    let keyboardDOMClass;\n    let keyboardDOM;\n    let options;\n\n    /**\n     * If first parameter is a string:\n     * Consider it as an element's class\n     */\n    if (typeof params[0] === \"string\") {\n      keyboardDOMClass = params[0].split(\".\").join(\"\");\n      keyboardDOM = document.querySelector(\n        `.${keyboardDOMClass}`\n      ) as KeyboardButton;\n      options = params[1];\n\n      /**\n       * If first parameter is an KeyboardButton\n       * Consider it as the keyboard DOM element\n       */\n    } else if (params[0] instanceof HTMLDivElement) {\n      /**\n       * This element must have a class, otherwise throw\n       */\n      if (!params[0].className) {\n        console.warn(\"Any DOM element passed as parameter must have a class.\");\n        throw new Error(\"KEYBOARD_DOM_CLASS_ERROR\");\n      }\n\n      keyboardDOMClass = params[0].className.split(\" \")[0];\n      keyboardDOM = params[0];\n      options = params[1];\n\n      /**\n       * Otherwise, search for .simple-keyboard DOM element\n       */\n    } else {\n      keyboardDOMClass = \"simple-keyboard\";\n      keyboardDOM = document.querySelector(\n        `.${keyboardDOMClass}`\n      ) as KeyboardButton;\n      options = params[0];\n    }\n\n    return {\n      keyboardDOMClass,\n      keyboardDOM,\n      options,\n    };\n  };\n\n  /**\n   * Getters\n   */\n  getOptions = (): KeyboardOptions => this.options;\n  getCaretPosition = (): number => this.caretPosition;\n  getCaretPositionEnd = (): number => this.caretPositionEnd;\n\n  /**\n   * Changes the internal caret position\n   * @param {number} position The caret's start position\n   * @param {number} positionEnd The caret's end position\n   */\n  setCaretPosition(position: number, endPosition = position): void {\n    this.caretPosition = position;\n    this.caretPositionEnd = endPosition;\n  }\n\n  /**\n   * Handles clicks made to keyboard buttons\n   * @param  {string} button The button's layout name.\n   */\n  handleButtonClicked(button: string): void {\n    const debug = this.options.debug;\n\n    /**\n     * Ignoring placeholder buttons\n     */\n    if (button === \"{//}\") return;\n\n    /**\n     * Calling onKeyPress\n     */\n    if (typeof this.options.onKeyPress === \"function\")\n      this.options.onKeyPress(button);\n\n    if (!this.input[this.options.inputName])\n      this.input[this.options.inputName] = \"\";\n\n    const updatedInput = this.utilities.getUpdatedInput(\n      button,\n      this.input[this.options.inputName],\n      this.caretPosition,\n      this.caretPositionEnd\n    );\n\n    if (\n      // If input will change as a result of this button press\n      this.input[this.options.inputName] !== updatedInput &&\n      // This pertains to the \"inputPattern\" option:\n      // If inputPattern isn't set\n      (!this.options.inputPattern ||\n        // Or, if it is set and if the pattern is valid - we proceed.\n        (this.options.inputPattern && this.inputPatternIsValid(updatedInput)))\n    ) {\n      /**\n       * If maxLength and handleMaxLength yield true, halting\n       */\n      if (\n        this.options.maxLength &&\n        this.utilities.handleMaxLength(this.input, updatedInput)\n      ) {\n        return;\n      }\n\n      this.input[this.options.inputName] = this.utilities.getUpdatedInput(\n        button,\n        this.input[this.options.inputName],\n        this.caretPosition,\n        this.caretPositionEnd,\n        true\n      );\n\n      if (debug) console.log(\"Input changed:\", this.getAllInputs());\n\n      if (this.options.debug) {\n        console.log(\n          \"Caret at: \",\n          this.getCaretPosition(),\n          this.getCaretPositionEnd(),\n          `(${this.keyboardDOMClass})`\n        );\n      }\n\n      /**\n       * Enforce syncInstanceInputs, if set\n       */\n      if (this.options.syncInstanceInputs) this.syncInstanceInputs();\n\n      /**\n       * Calling onChange\n       */\n      if (typeof this.options.onChange === \"function\")\n        this.options.onChange(this.getInput(this.options.inputName, true));\n\n      /**\n       * Calling onChangeAll\n       */\n      if (typeof this.options.onChangeAll === \"function\")\n        this.options.onChangeAll(this.getAllInputs());\n    }\n\n    if (debug) {\n      console.log(\"Key pressed:\", button);\n    }\n  }\n\n  /**\n   * Handles button mousedown\n   */\n  /* istanbul ignore next */\n  handleButtonMouseDown(button: string, e: KeyboardHandlerEvent): void {\n    if (e) {\n      /**\n       * Handle event options\n       */\n      if (this.options.preventMouseDownDefault) e.preventDefault();\n      if (this.options.stopMouseDownPropagation) e.stopPropagation();\n\n      /**\n       * Add active class\n       */\n      e.target.classList.add(this.activeButtonClass);\n    }\n\n    if (this.holdInteractionTimeout) clearTimeout(this.holdInteractionTimeout);\n    if (this.holdTimeout) clearTimeout(this.holdTimeout);\n\n    /**\n     * @type {boolean} Whether the mouse is being held onKeyPress\n     */\n    this.isMouseHold = true;\n\n    /**\n     * @type {object} Time to wait until a key hold is detected\n     */\n    if (!this.options.disableButtonHold) {\n      this.holdTimeout = window.setTimeout(() => {\n        if (\n          (this.isMouseHold &&\n            // TODO: This needs to be configurable through options\n            ((!button.includes(\"{\") && !button.includes(\"}\")) ||\n              button === \"{delete}\" ||\n              button === \"{backspace}\" ||\n              button === \"{bksp}\" ||\n              button === \"{space}\" ||\n              button === \"{tab}\")) ||\n          button === \"{arrowright}\" ||\n          button === \"{arrowleft}\" ||\n          button === \"{arrowup}\" ||\n          button === \"{arrowdown}\"\n        ) {\n          if (this.options.debug) console.log(\"Button held:\", button);\n\n          this.handleButtonHold(button);\n        }\n        clearTimeout(this.holdTimeout);\n      }, 500);\n    }\n  }\n\n  /**\n   * Handles button mouseup\n   */\n  handleButtonMouseUp(button?: string, e?: KeyboardHandlerEvent): void {\n    if (e) {\n      /**\n       * Handle event options\n       */\n      if (this.options.preventMouseUpDefault) e.preventDefault();\n      if (this.options.stopMouseUpPropagation) e.stopPropagation();\n    }\n\n    /**\n     * Remove active class\n     */\n    this.recurseButtons((buttonElement: Element) => {\n      buttonElement.classList.remove(this.activeButtonClass);\n    });\n\n    this.isMouseHold = false;\n    if (this.holdInteractionTimeout) clearTimeout(this.holdInteractionTimeout);\n\n    /**\n     * Calling onKeyReleased\n     */\n    if (button && typeof this.options.onKeyReleased === \"function\")\n      this.options.onKeyReleased(button);\n  }\n\n  /**\n   * Handles container mousedown\n   */\n  handleKeyboardContainerMouseDown(e: KeyboardHandlerEvent): void {\n    /**\n     * Handle event options\n     */\n    if (this.options.preventMouseDownDefault) e.preventDefault();\n  }\n\n  /**\n   * Handles button hold\n   */\n  /* istanbul ignore next */\n  handleButtonHold(button: string): void {\n    if (this.holdInteractionTimeout) clearTimeout(this.holdInteractionTimeout);\n\n    /**\n     * @type {object} Timeout dictating the speed of key hold iterations\n     */\n    this.holdInteractionTimeout = window.setTimeout(() => {\n      if (this.isMouseHold) {\n        this.handleButtonClicked(button);\n        this.handleButtonHold(button);\n      } else {\n        clearTimeout(this.holdInteractionTimeout);\n      }\n    }, 100);\n  }\n\n  /**\n   * Send a command to all simple-keyboard instances (if you have several instances).\n   */\n  syncInstanceInputs(): void {\n    this.dispatch((instance: SimpleKeyboard) => {\n      instance.replaceInput(this.input);\n      instance.setCaretPosition(this.caretPosition, this.caretPositionEnd);\n    });\n  }\n\n  /**\n   * Clear the keyboard’s input.\n   * @param {string} [inputName] optional - the internal input to select\n   */\n  clearInput(inputName: string): void {\n    inputName = inputName || this.options.inputName;\n    this.input[inputName] = \"\";\n\n    /**\n     * Reset caretPosition\n     */\n    this.setCaretPosition(0);\n\n    /**\n     * Enforce syncInstanceInputs, if set\n     */\n    if (this.options.syncInstanceInputs) this.syncInstanceInputs();\n  }\n\n  /**\n   * Get the keyboard’s input (You can also get it from the onChange prop).\n   * @param  {string} [inputName] optional - the internal input to select\n   */\n  getInput(inputName: string, skipSync = false): string {\n    inputName = inputName || this.options.inputName;\n\n    /**\n     * Enforce syncInstanceInputs, if set\n     */\n    if (this.options.syncInstanceInputs && !skipSync) this.syncInstanceInputs();\n\n    if (this.options.rtl) {\n      // Remove existing control chars\n      const inputWithoutRTLControl = this.input[inputName]\n        .replace(\"\\u202B\", \"\")\n        .replace(\"\\u202C\", \"\");\n\n      return \"\\u202B\" + inputWithoutRTLControl + \"\\u202C\";\n    } else {\n      return this.input[inputName];\n    }\n  }\n\n  /**\n   * Get all simple-keyboard inputs\n   */\n  getAllInputs(): KeyboardInput {\n    const output = {};\n    const inputNames = Object.keys(this.input);\n\n    inputNames.forEach((inputName) => {\n      output[inputName] = this.getInput(inputName, true);\n    });\n\n    return output;\n  }\n\n  /**\n   * Set the keyboard’s input.\n   * @param  {string} input the input value\n   * @param  {string} inputName optional - the internal input to select\n   */\n  setInput(input: string, inputName: string): void {\n    inputName = inputName || this.options.inputName;\n    this.input[inputName] = input;\n\n    /**\n     * Enforce syncInstanceInputs, if set\n     */\n    if (this.options.syncInstanceInputs) this.syncInstanceInputs();\n  }\n\n  /**\n   * Replace the input object (`keyboard.input`)\n   * @param  {object} inputObj The input object\n   */\n  replaceInput(inputObj: KeyboardInput): void {\n    this.input = inputObj;\n  }\n\n  /**\n   * Set new option or modify existing ones after initialization.\n   * @param  {object} options The options to set\n   */\n  setOptions(options = {}): void {\n    const changedOptions = this.changedOptions(options);\n    this.options = Object.assign(this.options, options);\n\n    if (changedOptions.length) {\n      if (this.options.debug) {\n        console.log(\"changedOptions\", changedOptions);\n      }\n\n      /**\n       * Some option changes require adjustments before re-render\n       */\n      this.onSetOptions(options);\n\n      /**\n       * Rendering\n       */\n      this.render();\n    }\n  }\n\n  /**\n   * Detecting changes to non-function options\n   * This allows us to ascertain whether a button re-render is needed\n   */\n  changedOptions(newOptions: Partial<KeyboardOptions>): string[] {\n    return Object.keys(newOptions).filter(\n      (optionName) =>\n        JSON.stringify(newOptions[optionName]) !==\n        JSON.stringify(this.options[optionName])\n    );\n  }\n\n  /**\n   * Executing actions depending on changed options\n   * @param  {object} options The options to set\n   */\n  onSetOptions(options: Partial<KeyboardOptions>): void {\n    if (options.inputName) {\n      /**\n       * inputName changed. This requires a caretPosition reset\n       */\n      if (this.options.debug) {\n        console.log(\"inputName changed. caretPosition reset.\");\n      }\n      this.setCaretPosition(null);\n    }\n  }\n\n  /**\n   * Remove all keyboard rows and reset keyboard values.\n   * Used internally between re-renders.\n   */\n  clear(): void {\n    this.keyboardDOM.innerHTML = \"\";\n    this.keyboardDOM.className = this.keyboardDOMClass;\n    this.buttonElements = {};\n  }\n\n  /**\n   * Send a command to all simple-keyboard instances at once (if you have multiple instances).\n   * @param  {function(instance: object, key: string)} callback Function to run on every instance\n   */\n  // eslint-disable-next-line no-unused-vars\n  dispatch(callback: (instance: SimpleKeyboard, key?: string) => void): void {\n    if (!window[\"SimpleKeyboardInstances\"]) {\n      console.warn(\n        `SimpleKeyboardInstances is not defined. Dispatch cannot be called.`\n      );\n      throw new Error(\"INSTANCES_VAR_ERROR\");\n    }\n\n    return Object.keys(window[\"SimpleKeyboardInstances\"]).forEach((key) => {\n      callback(window[\"SimpleKeyboardInstances\"][key], key);\n    });\n  }\n\n  /**\n   * Adds/Modifies an entry to the `buttonTheme`. Basically a way to add a class to a button.\n   * @param  {string} buttons List of buttons to select (separated by a space).\n   * @param  {string} className Classes to give to the selected buttons (separated by space).\n   */\n  addButtonTheme(buttons: string, className: string): void {\n    if (!className || !buttons) return;\n\n    buttons.split(\" \").forEach((button) => {\n      className.split(\" \").forEach((classNameItem) => {\n        if (!this.options.buttonTheme) this.options.buttonTheme = [];\n\n        let classNameFound = false;\n\n        /**\n         * If class is already defined, we add button to class definition\n         */\n        this.options.buttonTheme.map((buttonTheme) => {\n          if (buttonTheme.class.split(\" \").includes(classNameItem)) {\n            classNameFound = true;\n\n            const buttonThemeArray = buttonTheme.buttons.split(\" \");\n            if (!buttonThemeArray.includes(button)) {\n              classNameFound = true;\n              buttonThemeArray.push(button);\n              buttonTheme.buttons = buttonThemeArray.join(\" \");\n            }\n          }\n          return buttonTheme;\n        });\n\n        /**\n         * If class is not defined, we create a new entry\n         */\n        if (!classNameFound) {\n          this.options.buttonTheme.push({\n            class: classNameItem,\n            buttons: buttons,\n          });\n        }\n      });\n    });\n\n    this.render();\n  }\n\n  /**\n   * Removes/Amends an entry to the `buttonTheme`. Basically a way to remove a class previously added to a button through buttonTheme or addButtonTheme.\n   * @param  {string} buttons List of buttons to select (separated by a space).\n   * @param  {string} className Classes to give to the selected buttons (separated by space).\n   */\n  removeButtonTheme(buttons: string, className: string): void {\n    /**\n     * When called with empty parameters, remove all button themes\n     */\n    if (!buttons && !className) {\n      this.options.buttonTheme = [];\n      this.render();\n      return;\n    }\n\n    /**\n     * If buttons are passed and buttonTheme has items\n     */\n    if (\n      buttons &&\n      Array.isArray(this.options.buttonTheme) &&\n      this.options.buttonTheme.length\n    ) {\n      const buttonArray = buttons.split(\" \");\n      buttonArray.forEach((button) => {\n        this.options.buttonTheme.map((buttonTheme, index) => {\n          /**\n           * If className is set, we affect the buttons only for that class\n           * Otherwise, we afect all classes\n           */\n          if (\n            (className && className.includes(buttonTheme.class)) ||\n            !className\n          ) {\n            const filteredButtonArray = buttonTheme.buttons\n              .split(\" \")\n              .filter((item) => item !== button);\n\n            /**\n             * If buttons left, return them, otherwise, remove button Theme\n             */\n            if (filteredButtonArray.length) {\n              buttonTheme.buttons = filteredButtonArray.join(\" \");\n            } else {\n              this.options.buttonTheme.splice(index, 1);\n              buttonTheme = null;\n            }\n          }\n\n          return buttonTheme;\n        });\n      });\n\n      this.render();\n    }\n  }\n\n  /**\n   * Get the DOM Element of a button. If there are several buttons with the same name, an array of the DOM Elements is returned.\n   * @param  {string} button The button layout name to select\n   */\n  getButtonElement(button: string): KeyboardButton | KeyboardButton[] {\n    let output;\n\n    const buttonArr = this.buttonElements[button];\n    if (buttonArr) {\n      if (buttonArr.length > 1) {\n        output = buttonArr;\n      } else {\n        output = buttonArr[0];\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * This handles the \"inputPattern\" option\n   * by checking if the provided inputPattern passes\n   */\n  inputPatternIsValid(inputVal: string): boolean {\n    const inputPatternRaw = this.options.inputPattern;\n    let inputPattern;\n\n    /**\n     * Check if input pattern is global or targeted to individual inputs\n     */\n    if (inputPatternRaw instanceof RegExp) {\n      inputPattern = inputPatternRaw;\n    } else {\n      inputPattern = inputPatternRaw[this.options.inputName];\n    }\n\n    if (inputPattern && inputVal) {\n      const didInputMatch = inputPattern.test(inputVal);\n\n      if (this.options.debug) {\n        console.log(\n          `inputPattern (\"${inputPattern}\"): ${\n            didInputMatch ? \"passed\" : \"did not pass!\"\n          }`\n        );\n      }\n\n      return didInputMatch;\n    } else {\n      /**\n       * inputPattern doesn't seem to be set for the current input, or input is empty. Pass.\n       */\n      return true;\n    }\n  }\n\n  /**\n   * Handles simple-keyboard event listeners\n   */\n  setEventListeners(): void {\n    /**\n     * Only first instance should set the event listeners\n     */\n    if (this.isFirstKeyboardInstance || !this.allKeyboardInstances) {\n      if (this.options.debug) {\n        console.log(`Caret handling started (${this.keyboardDOMClass})`);\n      }\n\n      /**\n       * Event Listeners\n       */\n      document.addEventListener(\"keyup\", this.handleKeyUp);\n      document.addEventListener(\"keydown\", this.handleKeyDown);\n      document.addEventListener(\"mouseup\", this.handleMouseUp);\n      document.addEventListener(\"touchend\", this.handleTouchEnd);\n    }\n  }\n\n  /**\n   * Event Handler: KeyUp\n   */\n  handleKeyUp(event: KeyboardHandlerEvent): void {\n    this.caretEventHandler(event);\n\n    if (this.options.physicalKeyboardHighlight) {\n      this.physicalKeyboard.handleHighlightKeyUp(event);\n    }\n  }\n\n  /**\n   * Event Handler: KeyDown\n   */\n  handleKeyDown(event: KeyboardHandlerEvent): void {\n    if (this.options.physicalKeyboardHighlight) {\n      this.physicalKeyboard.handleHighlightKeyDown(event);\n    }\n  }\n\n  /**\n   * Event Handler: MouseUp\n   */\n  handleMouseUp(event: KeyboardHandlerEvent): void {\n    this.caretEventHandler(event);\n  }\n\n  /**\n   * Event Handler: TouchEnd\n   */\n  /* istanbul ignore next */\n  handleTouchEnd(event: KeyboardHandlerEvent): void {\n    this.caretEventHandler(event);\n  }\n\n  /**\n   * Called by {@link setEventListeners} when an event that warrants a cursor position update is triggered\n   */\n  caretEventHandler(event: KeyboardHandlerEvent): void {\n    let targetTagName: string;\n    if (event.target.tagName) {\n      targetTagName = event.target.tagName.toLowerCase();\n    }\n\n    this.dispatch((instance) => {\n      const isKeyboard =\n        event.target === instance.keyboardDOM ||\n        (event.target && instance.keyboardDOM.contains(event.target));\n\n      if (instance.isMouseHold) {\n        instance.isMouseHold = false;\n      }\n\n      if (\n        (targetTagName === \"textarea\" || targetTagName === \"input\") &&\n        \"selectionStart\" in event.target &&\n        \"selectionEnd\" in event.target &&\n        !instance.options.disableCaretPositioning\n      ) {\n        /**\n         * Tracks current cursor position\n         * As keys are pressed, text will be added/removed at that position within the input.\n         */\n        instance.setCaretPosition(\n          event.target.selectionStart,\n          event.target.selectionEnd\n        );\n\n        if (instance.options.debug) {\n          console.log(\n            \"Caret at: \",\n            instance.getCaretPosition(),\n            instance.getCaretPositionEnd(),\n            event && event.target.tagName.toLowerCase(),\n            `(${instance.keyboardDOMClass})`\n          );\n        }\n      } else if (instance.options.disableCaretPositioning || !isKeyboard) {\n        /**\n         * If we toggled off disableCaretPositioning, we must ensure caretPosition doesn't persist once reactivated.\n         */\n        instance.setCaretPosition(null);\n      }\n    });\n  }\n\n  /**\n   * Execute an operation on each button\n   */\n  recurseButtons(fn: any): void {\n    if (!fn) return;\n\n    Object.keys(this.buttonElements).forEach((buttonName) =>\n      this.buttonElements[buttonName].forEach(fn)\n    );\n  }\n\n  /**\n   * Destroy keyboard listeners and DOM elements\n   */\n  destroy(): void {\n    if (this.options.debug)\n      console.log(\n        `Destroying simple-keyboard instance: ${this.currentInstanceName}`\n      );\n\n    /**\n     * Remove document listeners\n     */\n    document.removeEventListener(\"keyup\", this.handleKeyUp);\n    document.removeEventListener(\"keydown\", this.handleKeyDown);\n    document.removeEventListener(\"mouseup\", this.handleMouseUp);\n    document.removeEventListener(\"touchend\", this.handleTouchEnd);\n    document.onpointerup = null;\n    document.ontouchend = null;\n    document.ontouchcancel = null;\n    document.onmouseup = null;\n\n    /**\n     * Remove buttons\n     */\n    let deleteButton = (buttonElement: KeyboardButton) => {\n      buttonElement.onpointerdown = null;\n      buttonElement.onpointerup = null;\n      buttonElement.onpointercancel = null;\n      buttonElement.ontouchstart = null;\n      buttonElement.ontouchend = null;\n      buttonElement.ontouchcancel = null;\n      buttonElement.onclick = null;\n      buttonElement.onmousedown = null;\n      buttonElement.onmouseup = null;\n\n      buttonElement.remove();\n      buttonElement = null;\n    };\n\n    this.recurseButtons(deleteButton);\n\n    this.recurseButtons = null;\n    deleteButton = null;\n\n    /**\n     * Remove wrapper events\n     */\n    this.keyboardDOM.onpointerdown = null;\n    this.keyboardDOM.ontouchstart = null;\n    this.keyboardDOM.onmousedown = null;\n\n    /**\n     * Clearing keyboard wrapper\n     */\n    this.clear();\n\n    /**\n     * Remove instance\n     */\n    window[\"SimpleKeyboardInstances\"][this.currentInstanceName] = null;\n    delete window[\"SimpleKeyboardInstances\"][this.currentInstanceName];\n\n    /**\n     * Reset initialized flag\n     */\n    this.initialized = false;\n  }\n\n  /**\n   * Process buttonTheme option\n   */\n  getButtonThemeClasses(button: string): string[] {\n    const buttonTheme = this.options.buttonTheme;\n    let buttonClasses: string[] = [];\n\n    if (Array.isArray(buttonTheme)) {\n      buttonTheme.forEach((themeObj) => {\n        if (\n          themeObj.class &&\n          typeof themeObj.class === \"string\" &&\n          themeObj.buttons &&\n          typeof themeObj.buttons === \"string\"\n        ) {\n          const themeObjClasses = themeObj.class.split(\" \");\n          const themeObjButtons = themeObj.buttons.split(\" \");\n\n          if (themeObjButtons.includes(button)) {\n            buttonClasses = [...buttonClasses, ...themeObjClasses];\n          }\n        } else {\n          console.warn(\n            `Incorrect \"buttonTheme\". Please check the documentation.`,\n            themeObj\n          );\n        }\n      });\n    }\n\n    return buttonClasses;\n  }\n\n  /**\n   * Process buttonAttributes option\n   */\n  setDOMButtonAttributes(button: string, callback: any): void {\n    const buttonAttributes = this.options.buttonAttributes;\n\n    if (Array.isArray(buttonAttributes)) {\n      buttonAttributes.forEach((attrObj) => {\n        if (\n          attrObj.attribute &&\n          typeof attrObj.attribute === \"string\" &&\n          attrObj.value &&\n          typeof attrObj.value === \"string\" &&\n          attrObj.buttons &&\n          typeof attrObj.buttons === \"string\"\n        ) {\n          const attrObjButtons = attrObj.buttons.split(\" \");\n\n          if (attrObjButtons.includes(button)) {\n            callback(attrObj.attribute, attrObj.value);\n          }\n        } else {\n          console.warn(\n            `Incorrect \"buttonAttributes\". Please check the documentation.`,\n            attrObj\n          );\n        }\n      });\n    }\n  }\n\n  onTouchDeviceDetected() {\n    /**\n     * Processing autoTouchEvents\n     */\n    this.processAutoTouchEvents();\n\n    /**\n     * Disabling contextual window on touch devices\n     */\n    this.disableContextualWindow();\n  }\n\n  /**\n   * Disabling contextual window for hg-button\n   */\n  /* istanbul ignore next */\n  disableContextualWindow() {\n    window.oncontextmenu = (event: KeyboardHandlerEvent) => {\n      if (event.target.classList.contains(\"hg-button\")) {\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n      }\n    };\n  }\n\n  /**\n   * Process autoTouchEvents option\n   */\n  processAutoTouchEvents() {\n    if (this.options.autoUseTouchEvents) {\n      this.options.useTouchEvents = true;\n\n      if (this.options.debug) {\n        console.log(\n          `autoUseTouchEvents: Touch device detected, useTouchEvents enabled.`\n        );\n      }\n    }\n  }\n\n  /**\n   * Executes the callback function once simple-keyboard is rendered for the first time (on initialization).\n   */\n  onInit() {\n    if (this.options.debug) {\n      console.log(`${this.keyboardDOMClass} Initialized`);\n    }\n\n    /**\n     * setEventListeners\n     */\n    this.setEventListeners();\n\n    if (typeof this.options.onInit === \"function\") this.options.onInit();\n  }\n\n  /**\n   * Executes the callback function before a simple-keyboard render.\n   */\n  beforeFirstRender() {\n    /**\n     * Performing actions when touch device detected\n     */\n    if (this.utilities.isTouchDevice()) {\n      this.onTouchDeviceDetected();\n    }\n\n    if (typeof this.options.beforeFirstRender === \"function\")\n      this.options.beforeFirstRender();\n\n    /**\n     * Notify about PointerEvents usage\n     */\n    if (\n      this.isFirstKeyboardInstance &&\n      this.utilities.pointerEventsSupported() &&\n      !this.options.useTouchEvents &&\n      !this.options.useMouseEvents\n    ) {\n      if (this.options.debug) {\n        console.log(\"Using PointerEvents as it is supported by this browser\");\n      }\n    }\n\n    /**\n     * Notify about touch events usage\n     */\n    if (this.options.useTouchEvents) {\n      if (this.options.debug) {\n        console.log(\n          \"useTouchEvents has been enabled. Only touch events will be used.\"\n        );\n      }\n    }\n  }\n\n  /**\n   * Executes the callback function before a simple-keyboard render.\n   */\n  beforeRender() {\n    if (typeof this.options.beforeRender === \"function\")\n      this.options.beforeRender();\n  }\n\n  /**\n   * Executes the callback function every time simple-keyboard is rendered (e.g: when you change layouts).\n   */\n  onRender() {\n    if (typeof this.options.onRender === \"function\") this.options.onRender();\n  }\n\n  /**\n   * Executes the callback function once all modules have been loaded\n   */\n  onModulesLoaded() {\n    if (typeof this.options.onModulesLoaded === \"function\")\n      this.options.onModulesLoaded(this);\n  }\n\n  /**\n   * Register module\n   */\n  registerModule = (name: string, initCallback: any) => {\n    if (!this.modules[name]) this.modules[name] = {};\n\n    initCallback(this.modules[name]);\n  };\n\n  /**\n   * Load modules\n   */\n  loadModules() {\n    if (Array.isArray(this.options.modules)) {\n      this.options.modules.forEach((KeyboardModule) => {\n        const keyboardModule = new KeyboardModule();\n        keyboardModule.init(this);\n      });\n\n      this.keyboardPluginClasses = \"modules-loaded\";\n\n      this.render();\n      this.onModulesLoaded();\n    }\n  }\n\n  /**\n   * Get module prop\n   */\n  getModuleProp(name: string, prop: string) {\n    if (!this.modules[name]) return false;\n\n    return this.modules[name][prop];\n  }\n\n  /**\n   * getModulesList\n   */\n  getModulesList() {\n    return Object.keys(this.modules);\n  }\n\n  /**\n   * Parse Row DOM containers\n   */\n  parseRowDOMContainers(\n    rowDOM: HTMLDivElement,\n    rowIndex: number,\n    containerStartIndexes: number[],\n    containerEndIndexes: number[]\n  ) {\n    const rowDOMArray = Array.from(rowDOM.children);\n    let removedElements = 0;\n\n    if (rowDOMArray.length) {\n      containerStartIndexes.forEach((startIndex, arrIndex) => {\n        const endIndex = containerEndIndexes[arrIndex];\n\n        /**\n         * If there exists a respective end index\n         * if end index comes after start index\n         */\n        if (!endIndex || !(endIndex > startIndex)) {\n          return false;\n        }\n\n        /**\n         * Updated startIndex, endIndex\n         * This is since the removal of buttons to place a single button container\n         * results in a modified array size\n         */\n        const updated_startIndex = startIndex - removedElements;\n        const updated_endIndex = endIndex - removedElements;\n\n        /**\n         * Create button container\n         */\n        const containerDOM = document.createElement(\"div\");\n        containerDOM.className += \"hg-button-container\";\n        const containerUID = `${this.options.layoutName}-r${rowIndex}c${arrIndex}`;\n        containerDOM.setAttribute(\"data-skUID\", containerUID);\n\n        /**\n         * Taking elements due to be inserted into container\n         */\n        const containedElements = rowDOMArray.splice(\n          updated_startIndex,\n          updated_endIndex - updated_startIndex + 1\n        );\n        removedElements = updated_endIndex - updated_startIndex;\n\n        /**\n         * Inserting elements to container\n         */\n        containedElements.forEach((element) =>\n          containerDOM.appendChild(element)\n        );\n\n        /**\n         * Adding container at correct position within rowDOMArray\n         */\n        rowDOMArray.splice(updated_startIndex, 0, containerDOM);\n\n        /**\n         * Clearing old rowDOM children structure\n         */\n        rowDOM.innerHTML = \"\";\n\n        /**\n         * Appending rowDOM new children list\n         */\n        rowDOMArray.forEach((element) => rowDOM.appendChild(element));\n\n        if (this.options.debug) {\n          console.log(\n            \"rowDOMContainer\",\n            containedElements,\n            updated_startIndex,\n            updated_endIndex,\n            removedElements + 1\n          );\n        }\n      });\n    }\n\n    return rowDOM;\n  }\n\n  /**\n   * getKeyboardClassString\n   */\n  getKeyboardClassString = (...baseDOMClasses: any[]) => {\n    const keyboardClasses = [this.keyboardDOMClass, ...baseDOMClasses].filter(\n      (DOMClass) => !!DOMClass\n    );\n\n    return keyboardClasses.join(\" \");\n  };\n\n  /**\n   * Renders rows and buttons as per options\n   */\n  render() {\n    /**\n     * Clear keyboard\n     */\n    this.clear();\n\n    /**\n     * Calling beforeFirstRender\n     */\n    if (!this.initialized) {\n      this.beforeFirstRender();\n    }\n\n    /**\n     * Calling beforeRender\n     */\n    this.beforeRender();\n\n    const layoutClass = `hg-layout-${this.options.layoutName}`;\n    const layout = this.options.layout || getDefaultLayout();\n    const useTouchEvents = this.options.useTouchEvents || false;\n    const useTouchEventsClass = useTouchEvents ? \"hg-touch-events\" : \"\";\n    const useMouseEvents = this.options.useMouseEvents || false;\n    const disableRowButtonContainers = this.options.disableRowButtonContainers;\n\n    /**\n     * Adding themeClass, layoutClass to keyboardDOM\n     */\n    this.keyboardDOM.className = this.getKeyboardClassString(\n      this.options.theme,\n      layoutClass,\n      this.keyboardPluginClasses,\n      useTouchEventsClass\n    );\n\n    /**\n     * Iterating through each row\n     */\n    layout[this.options.layoutName].forEach((row, rIndex) => {\n      const rowArray = row.split(\" \");\n\n      /**\n       * Creating empty row\n       */\n      let rowDOM = document.createElement(\"div\");\n      rowDOM.className += \"hg-row\";\n\n      /**\n       * Tracking container indicators in rows\n       */\n      const containerStartIndexes: number[] = [];\n      const containerEndIndexes: number[] = [];\n\n      /**\n       * Iterating through each button in row\n       */\n      rowArray.forEach((button, bIndex) => {\n        /**\n         * Check if button has a container indicator\n         */\n        const buttonHasContainerStart =\n          !disableRowButtonContainers &&\n          typeof button === \"string\" &&\n          button.length > 1 &&\n          button.indexOf(\"[\") === 0;\n\n        const buttonHasContainerEnd =\n          !disableRowButtonContainers &&\n          typeof button === \"string\" &&\n          button.length > 1 &&\n          button.indexOf(\"]\") === button.length - 1;\n\n        /**\n         * Save container start index, if applicable\n         */\n        if (buttonHasContainerStart) {\n          containerStartIndexes.push(bIndex);\n\n          /**\n           * Removing indicator\n           */\n          button = button.replace(/\\[/g, \"\");\n        }\n\n        if (buttonHasContainerEnd) {\n          containerEndIndexes.push(bIndex);\n\n          /**\n           * Removing indicator\n           */\n          button = button.replace(/\\]/g, \"\");\n        }\n\n        /**\n         * Processing button options\n         */\n        const fctBtnClass = this.utilities.getButtonClass(button);\n        const buttonDisplayName = this.utilities.getButtonDisplayName(\n          button,\n          this.options.display,\n          this.options.mergeDisplay\n        );\n\n        /**\n         * Creating button\n         */\n        const buttonType = this.options.useButtonTag ? \"button\" : \"div\";\n        const buttonDOM = document.createElement(buttonType);\n        buttonDOM.className += `hg-button ${fctBtnClass}`;\n\n        /**\n         * Adding buttonTheme\n         */\n        buttonDOM.classList.add(...this.getButtonThemeClasses(button));\n\n        /**\n         * Adding buttonAttributes\n         */\n        this.setDOMButtonAttributes(\n          button,\n          (attribute: string, value: string) => {\n            buttonDOM.setAttribute(attribute, value);\n          }\n        );\n\n        this.activeButtonClass = \"hg-activeButton\";\n\n        /**\n         * Handle button click event\n         */\n        /* istanbul ignore next */\n        if (\n          this.utilities.pointerEventsSupported() &&\n          !useTouchEvents &&\n          !useMouseEvents\n        ) {\n          /**\n           * Handle PointerEvents\n           */\n          buttonDOM.onpointerdown = (e: KeyboardHandlerEvent) => {\n            this.handleButtonClicked(button);\n            this.handleButtonMouseDown(button, e);\n          };\n          buttonDOM.onpointerup = (e: KeyboardHandlerEvent) => {\n            this.handleButtonMouseUp(button, e);\n          };\n          buttonDOM.onpointercancel = (e: KeyboardHandlerEvent) => {\n            this.handleButtonMouseUp(button, e);\n          };\n        } else {\n          /**\n           * Fallback for browsers not supporting PointerEvents\n           */\n          if (useTouchEvents) {\n            /**\n             * Handle touch events\n             */\n            buttonDOM.ontouchstart = (e: KeyboardHandlerEvent) => {\n              this.handleButtonClicked(button);\n              this.handleButtonMouseDown(button, e);\n            };\n            buttonDOM.ontouchend = (e: KeyboardHandlerEvent) => {\n              this.handleButtonMouseUp(button, e);\n            };\n            buttonDOM.ontouchcancel = (e: KeyboardHandlerEvent) => {\n              this.handleButtonMouseUp(button, e);\n            };\n          } else {\n            /**\n             * Handle mouse events\n             */\n            buttonDOM.onclick = () => {\n              this.isMouseHold = false;\n              this.handleButtonClicked(button);\n            };\n            buttonDOM.onmousedown = (e: KeyboardHandlerEvent) => {\n              this.handleButtonMouseDown(button, e);\n            };\n            buttonDOM.onmouseup = (e: KeyboardHandlerEvent) => {\n              this.handleButtonMouseUp(button, e);\n            };\n          }\n        }\n\n        /**\n         * Adding identifier\n         */\n        buttonDOM.setAttribute(\"data-skBtn\", button);\n\n        /**\n         * Adding unique id\n         * Since there's no limit on spawning same buttons, the unique id ensures you can style every button\n         */\n        const buttonUID = `${this.options.layoutName}-r${rIndex}b${bIndex}`;\n        buttonDOM.setAttribute(\"data-skBtnUID\", buttonUID);\n\n        /**\n         * Adding button label to button\n         */\n        const buttonSpanDOM = document.createElement(\"span\");\n        buttonSpanDOM.innerHTML = buttonDisplayName;\n        buttonDOM.appendChild(buttonSpanDOM);\n\n        /**\n         * Adding to buttonElements\n         */\n        if (!this.buttonElements[button]) this.buttonElements[button] = [];\n\n        this.buttonElements[button].push(buttonDOM);\n\n        /**\n         * Appending button to row\n         */\n        rowDOM.appendChild(buttonDOM);\n      });\n\n      /**\n       * Parse containers in row\n       */\n      rowDOM = this.parseRowDOMContainers(\n        rowDOM,\n        rIndex,\n        containerStartIndexes,\n        containerEndIndexes\n      );\n\n      /**\n       * Appending row to keyboard\n       */\n      this.keyboardDOM.appendChild(rowDOM);\n    });\n\n    /**\n     * Calling onRender\n     */\n    this.onRender();\n\n    if (!this.initialized) {\n      /**\n       * Ensures that onInit and beforeFirstRender are only called once per instantiation\n       */\n      this.initialized = true;\n\n      /**\n       * Handling parent events\n       */\n      /* istanbul ignore next */\n      if (\n        this.utilities.pointerEventsSupported() &&\n        !useTouchEvents &&\n        !useMouseEvents\n      ) {\n        document.onpointerup = () => this.handleButtonMouseUp();\n        this.keyboardDOM.onpointerdown = (e: KeyboardHandlerEvent) =>\n          this.handleKeyboardContainerMouseDown(e);\n      } else if (useTouchEvents) {\n        /**\n         * Handling ontouchend, ontouchcancel\n         */\n        document.ontouchend = () => this.handleButtonMouseUp();\n        document.ontouchcancel = () => this.handleButtonMouseUp();\n\n        this.keyboardDOM.ontouchstart = (e: KeyboardHandlerEvent) =>\n          this.handleKeyboardContainerMouseDown(e);\n      } else if (!useTouchEvents) {\n        /**\n         * Handling mouseup\n         */\n        document.onmouseup = () => this.handleButtonMouseUp();\n        this.keyboardDOM.onmousedown = (e: KeyboardHandlerEvent) =>\n          this.handleKeyboardContainerMouseDown(e);\n      }\n\n      /**\n       * Calling onInit\n       */\n      this.onInit();\n    }\n  }\n}\n\nexport default SimpleKeyboard;\n","import SimpleKeyboard from \"./components/Keyboard\";\nexport default SimpleKeyboard;\n","export const getDefaultLayout = () => {\n  return {\n    default: [\n      \"` 1 2 3 4 5 6 7 8 9 0 - = {bksp}\",\n      \"{tab} q w e r t y u i o p [ ] \\\\\",\n      \"{lock} a s d f g h j k l ; ' {enter}\",\n      \"{shift} z x c v b n m , . / {shift}\",\n      \".com @ {space}\",\n    ],\n    shift: [\n      \"~ ! @ # $ % ^ & * ( ) _ + {bksp}\",\n      \"{tab} Q W E R T Y U I O P { } |\",\n      '{lock} A S D F G H J K L : \" {enter}',\n      \"{shift} Z X C V B N M < > ? {shift}\",\n      \".com @ {space}\",\n    ],\n  };\n};\n"],"sourceRoot":""}
